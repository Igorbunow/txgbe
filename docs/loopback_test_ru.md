# Инструкция по тестированию двухпортовой сетевой карты (SFP+) методом физической петли

## Часть 1. Принцип действия и теоретическое обоснование

### Суть метода

Обычно, если вы назначите два IP-адреса из одной подсети на два порта одного сервера, Linux (как умная ОС) поймет, что оба адреса принадлежат ему, и пустит трафик через виртуальный интерфейс `lo` (loopback) внутри оперативной памяти, минуя физическую карту и кабель.

Чтобы проверить «железо» (трансиверы, пайку портов, ASIC чипа), нам нужно обмануть ОС. Для этого используются **Network Namespaces (netns)**. Мы изолируем порты в разные логические пространства, чтобы для ОС они выглядели как два абсолютно разных компьютера.

### Обоснование настроек (почему мы это делаем)

1. **Sysctl Tuning (net.core...):** Стандартные настройки Linux оптимизированы для 1Gbps и экономии памяти. Для тестов 10G/25G/100G буферы сокетов (Rmem/Wmem) и очереди (backlog) становятся узким горлышком. Мы увеличиваем их, чтобы тестировать предел карты, а не предел настроек ядра по умолчанию.
2. **MTU 9000 (Jumbo Frames):** Увеличивает размер пакета. Это снижает нагрузку на CPU (меньше прерываний на тот же объем данных) и увеличивает эффективность передачи («payload» к заголовкам).
3. **TSO/GSO/SG (Offloading):** Включение `ethtool -K ... on` перекладывает задачу нарезки данных на сегменты и подсчет контрольных сумм с процессора (CPU) на сетевую карту (NIC). Без этого вы упретесь в 100% загрузку CPU раньше, чем загрузите канал.
4. **CPU Pinning (Taskset):** Привязка процессов `iperf3` к конкретным ядрам процессора. Это критично для исключения переключений контекста и попадания трафика в кэш разных NUMA-нод (если система многопроцессорная).

---

## Часть 2. Подготовка и настройка

**Требования:**

* Установленные пакеты: `iperf3`, `ethtool`, `iproute2`, `pciutils`.
* Физическое соединение: Порт 0 и Порт 1 соединены патч-кордом (оптическим или DAC).

### Шаг 0. Предварительная установка инструментов

Перед началом работы необходимо убедиться, что все диагностические утилиты установлены. `mpstat` входит в пакет `sysstat`, а `lspci` — в `pciutils`.

```bash
# Установка необходимых инструментов (Debian/Ubuntu)
sudo apt update
sudo apt install -y iperf3 ethtool pciutils sysstat iproute2 htop

```

### Шаг 1. Скрипт конфигурации окружения

Создайте файл `prepare_test.sh`. В нем мы систематизируем ваши заметки и добавим переменные для удобства.

**Внимание:** Замените `IFACE_A` и `IFACE_B` на ваши реальные имена интерфейсов.

```bash
#!/bin/bash

# === КОНФИГУРАЦИЯ ===
IFACE_A="enP5p1s0f0"  # Интерфейс для Sender
IFACE_B="enP5p1s0f1"  # Интерфейс для Receiver
NS_A="ns_sender"
NS_B="ns_receiver"
IP_A="10.0.0.1/24"
IP_B="10.0.0.2/24"

echo "[INFO] Применяем системный тюнинг ядра..."
# Увеличение очереди backlog (критично, чтобы ядро успевало обрабатывать входящие прерывания)
sysctl -w net.core.netdev_max_backlog=30000
# Увеличение глобальных буферов сокетов
sysctl -w net.core.rmem_max=134217728
sysctl -w net.core.wmem_max=134217728
sysctl -w net.core.rmem_default=134217728
sysctl -w net.core.wmem_default=134217728
sysctl -w net.core.optmem_max=20480
# Тюнинг TCP стека (окна, timestamp, SACK)
sysctl -w net.ipv4.tcp_rmem="4096 87380 134217728"
sysctl -w net.ipv4.tcp_wmem="4096 65536 134217728"
sysctl -w net.ipv4.tcp_window_scaling=1
sysctl -w net.ipv4.tcp_timestamps=1
sysctl -w net.ipv4.tcp_sack=1

echo "[INFO] Очистка старых неймспейсов..."
ip netns del $NS_A 2>/dev/null
ip netns del $NS_B 2>/dev/null

echo "[INFO] Создание неймспейсов..."
ip netns add $NS_A
ip netns add $NS_B

echo "[INFO] Перенос физических интерфейсов в неймспейсы..."
ip link set $IFACE_A netns $NS_A
ip link set $IFACE_B netns $NS_B

echo "[INFO] Настройка интерфейса Sender ($IFACE_A)..."
ip netns exec $NS_A ip addr add $IP_A dev $IFACE_A
ip netns exec $NS_A ip link set $IFACE_A up
ip netns exec $NS_A ip link set dev $IFACE_A mtu 9000
# Включаем аппаратные оффлоады (Segmentation Offload)
ip netns exec $NS_A ethtool -K $IFACE_A tso on gso on sg on gro on

echo "[INFO] Настройка интерфейса Receiver ($IFACE_B)..."
ip netns exec $NS_B ip addr add $IP_B dev $IFACE_B
ip netns exec $NS_B ip link set $IFACE_B up
ip netns exec $NS_B ip link set dev $IFACE_B mtu 9000
ip netns exec $NS_B ethtool -K $IFACE_B tso on gso on sg on gro on

echo "[INFO] Применение локальных настроек TCP внутри неймспейсов..."
# Важно: неймспейсы имеют свои изолированные стеки TCP/IP
for NS in $NS_A $NS_B; do
    ip netns exec $NS sysctl -w net.ipv4.tcp_rmem="4096 87380 67108864" >/dev/null
    ip netns exec $NS sysctl -w net.ipv4.tcp_wmem="4096 65536 67108864" >/dev/null
done

echo "[SUCCESS] Настройка завершена. Интерфейсы готовы к тесту."

```

### Шаг 2.  Верификация настроек (Namespace и IP)


После запуска скрипта настройки (`prepare_test.sh`) критически важно убедиться, что неймспейсы создались, интерфейсы "переехали" в них и адреса присвоились корректно.

**Используйте следующую команду для сводной проверки:**

```bash
# Проверка наличия неймспейсов
ip netns list

# Проверка состояния интерфейсов и адресов во ВСЕХ неймспейсах одной командой
# Флаг -c включает цветной вывод, -br (brief) делает вывод компактным
ip -c -all netns exec ip -br addr show
ip -c -all netns exec ip -br link show

# Вывод всей информации
ip -c -all netns exec ip a  show
```

*Ожидаемый результат:* Вы должны увидеть записи для `ns_sender` и `ns_receiver`, где статус интерфейсов `UP`, а адреса `10.0.0.1` и `10.0.0.2` корректно назначены.

**Дополнительно (Sanity Check — проверка связности):**
Перед запуском `iperf3` всегда стоит пустить простой пинг, чтобы убедиться, что ARP-записи разрешились:

```bash
ip netns exec ns_sender ping -c 3 10.0.0.2

```

### Шаг 3. Смотрим параметры **offload**

```bash
ip netns exec ns_sender   ethtool -k enP5p1s0f0
ip netns exec ns_receiver ethtool -k enP5p1s0f1
```

Это механизмы, при которых сетевой адаптер берет на себя обработку сетевого трафика, чтобы разгрузить центральный процессор (CPU).

В выводе вы увидите множество строк. Самые важные из них обычно делятся на три категории:

**a) Offload при передаче (Transmit)**
*   **tx-checksumming**: Вычисление контрольных сумм протоколов (TCP/UDP) "на лету" железом, а не процессором.
*   **tcp-segmentation-offload (TSO)**: Разбивка больших кусков данных на сегменты TCP прямо в сетевой карте.
*   **tx-udp_tnl-segmentation**: Разбивка пакетов в туннелях (VXLAN/GRE) для UDP.

**b) Offload при приеме (Receive)**
*   **rx-checksumming**: Проверка контрольных сумм железом.
*   **generic-receive-offload (GRO)**: Сборка маленьких пакетов в один большой перед передачей ядру (уменьшает накладные расходы).
*   **large-receive-offload (LRO)**: Аналог GRO, но для больших объемов (обычно применяется на серверах).

**c) Специализированные возможности**
*   **rx-vlan-offload / tx-vlan-offload**: Добавление и удаление VLAN-тегов на лету.
*   **ntuple-filters**: Аппаратная фильтрация потоков (используется для RSS — распределения нагрузки по ядрам CPU, или для точной маршрутизации в DPDK).
*   **tx-udp_tnl-csum-segmentation**: Работа с контрольными суммами для туннелей.

---

## Часть 3. Проведение тестирования

### 1. Проверка состояния линка

Перед запуском трафика убедитесь, что линки поднялись и видят друг друга.

```bash
# Проверка Sender
ip netns exec ns_sender ethtool enP5p1s0f0 | grep -E "Speed|Duplex|Link detected"

# Проверка Receiver
ip netns exec ns_receiver ethtool enP5p1s0f1 | grep -E "Speed|Duplex|Link detected"

```

*Должно быть: Speed: 10000Mb/s (или ваша скорость), Link detected: yes.*

### 2. Запуск мониторинга ошибок (в отдельном терминале)

Крайне важно мониторить ошибки в реальном времени.

```bash
watch -n 1 "echo '--- SENDER ---'; ip netns exec ns_sender ethtool -S enP5p1s0f0 | grep -E 'err|drop|loss|missed|crc'; echo ''; echo '--- RECEIVER ---'; ip netns exec ns_receiver ethtool -S enP5p1s0f1 | grep -E 'err|drop|loss|missed|crc'"

```

### 3. Запуск нагрузочного тестирования (iperf3)

Мы используем флаг `-P` (parallel streams) для насыщения канала и `-Z` (zerocopy) для снижения нагрузки на CPU (если iperf3 свежий).

**Терминал 1 (Сервер/Receiver):**

```bash
# Запуск сервера, привязанного к ядрам 0-3
ip netns exec ns_receiver taskset -c 0-3 iperf3 -s

```

**Терминал 2 (Клиент/Sender):**

```bash
# Запуск клиента, привязанного к ядрам 4-7. 
# -t 30: время 30 сек
# -P 8: 8 потоков (оптимально для 10G+)
# -R: Reverse mode (клиент качает, сервер отдает). Рекомендуется прогнать тест с -R и без него.
ip netns exec ns_sender taskset -c 4-7 iperf3 -c 10.0.0.2 -t 30 -P 8 -R

```

---

## Часть 4. Расширенная диагностика (Missing Commands)

В ваших заметках упущены некоторые критически важные команды для диагностики аппаратных проблем и переполнения буферов. Добавьте их в чек-лист.

### 1. Проверка кольцевых буферов (Ring Buffers)

Частая причина дропов (`rx_missed_errors`) — переполнение аппаратного буфера карты.

```bash
ip netns exec ns_sender ethtool -g enP5p1s0f0

```

*Что смотреть:* Раздел `Current hardware settings`. Если `RX` меньше `Pre-set maximums`, и при тесте растут дропы — увеличивайте буфер командой: `ethtool -G enP5p1s0f0 rx 4096` (или максимум, который поддерживает карта).

### 2. Проверка Pause Frames (Flow Control)

Если один порт не справляется с обработкой, он может слать "PAUSE" фреймы, заставляя передатчик замолчать. Это снижает скорость.

```bash
ip netns exec ns_sender ethtool -a enP5p1s0f0

```

*Что смотреть:* Включены ли `Rx` и `Tx`. Для чистого теста производительности их иногда отключают (`ethtool -A interface rx off tx off`), чтобы увидеть реальные дропы, а не искусственное занижение скорости.

### 3. Проверка прерываний (Coalesce settings)

Настройки того, как часто карта дергает процессор.

```bash
ip netns exec ns_sender ethtool -c enP5p1s0f0

```

*Зачем:* Слишком частые прерывания грузят CPU. Adaptive-RX должен быть обычно `on`.

### 4. Проверка ширины линии PCIe (Lspci Detail)

Вы указали `lspci`, но важно проверить, не «отвалилась» ли карта в более низкий режим (например, x4 вместо x8).

```bash
# Смотрим на Speed и Width.
# Пример: LnkSta: Speed 8GT/s, Width x8
lspci -s 05:01:00.0 -vvv | grep LnkSta

```

### 5. Температура трансивера

При нагрузке SFP модуль может перегреваться.

```bash
# Смотрим раздел "Laser bias current" и "Temperature"
ip netns exec ns_sender ethtool -m enP5p1s0f0

```

### 6. Мониторинг загрузки CPU по ядрам

Важно убедиться, что одно ядро не долбится в 100% (softirq), пока остальные отдыхают.

```bash
mpstat -P ALL 1

```

*Что искать:* Высокий % в колонке `%soft` (software interrupts).

`mpstat -P ALL 1` в стандартном виде просто выводит новые строки вниз, что неудобно для визуального мониторинга в реальном времени.

**Вариант А: Использование `watch` (статичная картинка)**
Чтобы зафиксировать вывод `mpstat` на месте, оберните его в `watch`. Мы заставим `mpstat` сделать один замер и выйти, а `watch` будет перезапускать его.

```bash
# -n 1 : обновление раз в секунду
# --color : сохранение цветов
watch --color -n 1 "mpstat -P ALL 1 1"

```

**Вариант Б: `htop` (рекомендуемый, наглядный)**
Для визуальной оценки распределения нагрузки по ядрам лучше использовать `htop`.

```bash
htop

```

*Настройка htop:* Нажмите `F2` -> `Display options` -> Поставьте галочку `Detailed CPU time`. Это покажет, сколько времени уходит на `Software IRQ` (si) — это именно то, что грузит процессор при обработке сетевых пакетов.

### 7. Проверку **NUMA-архитектуры**

В контексте высокоскоростных тестов (10G/25G+) критично добавить проверку **NUMA-архитектуры**.

Если сетевая карта вставлена в слот PCIe, который обслуживается процессором №1, а `iperf` вы привязали к ядрам процессора №0, производительность упадет из-за трансферов через QPI/UPI шину между процессорами.

**Добавьте проверку локальности NUMA:**

```bash
# Узнать, к какой NUMA-ноде привязана сетевая карта
cat /sys/class/net/enP5p1s0f0/device/numa_node

```

*Если вывод `-1`, значит система не знает о NUMA (часто на десктопах). Если `0` или `1` — убедитесь, что в команде `taskset` вы используете ядра именно этого процессора.*

Посмотреть топологию процессора и кэшей:

```bash
lscpu | grep NUMA

```

**Проверка версий прошивок:**
Иногда проблемы кроются в старой прошивке карты. Добавьте в отчет о системе:

```bash
ip netns exec ns_sender ethtool -i enP5p1s0f0 | grep -E "driver|firmware"


---

## Часть 5. Возврат системы в исходное состояние (Cleanup)

После завершения тестов необходимо корректно вернуть сетевые карты под управление основной операционной системы, сбросить IP-адреса и вернуть стандартный размер пакета (MTU 1500).

Создайте файл `restore_default.sh`:

```bash
#!/bin/bash

IFACE_A="enP5p1s0f0"
IFACE_B="enP5p1s0f1"
NS_A="ns_sender"
NS_B="ns_receiver"

echo "[INFO] Удаление тестовых неймспейсов..."
# При удалении неймспейса физические интерфейсы 
# АВТОМАТИЧЕСКИ возвращаются в default namespace
ip netns del $NS_A 2>/dev/null
ip netns del $NS_B 2>/dev/null

echo "[INFO] Сброс настроек интерфейсов в Default Namespace..."
# После возврата интерфейсы могут сохранить настройки из неймспейса
# 1. Очищаем IP-адреса (чтобы не было конфликтов в основной сети)
ip addr flush dev $IFACE_A
ip addr flush dev $IFACE_B

# 2. Возвращаем стандартный MTU
ip link set dev $IFACE_A mtu 1500
ip link set dev $IFACE_B mtu 1500

# 3. (Опционально) Выключаем Promiscuous mode и лишние оффлоады, если нужно
# Обычно достаточно перезагрузки драйвера, но можно и вручную:
# ip link set dev $IFACE_A promisc off
# ip link set dev $IFACE_B promisc off

echo "[INFO] Применение системных настроек sysctl по умолчанию..."
# Настройки sysctl, сделанные через -w, сохраняются до перезагрузки.
# Эта команда загружает настройки из /etc/sysctl.conf, перезаписывая наши изменения
sysctl --system > /dev/null

echo "[CHECK] Текущий статус интерфейсов:"
ip -br link show dev $IFACE_A
ip -br link show dev $IFACE_B

```

### Как проверить, что всё вернулось:

**1. Проверяем, что неймспейсы удалились**
Попробуйте выполнить команду, которую мы использовали при тестах:

```bash
ip netns exec ns_sender ethtool enP5p1s0f0

```

> **Ожидаемый результат:** Ошибка `Object "ns_sender" is unknown, try "ip netns help"`.
> *Это значит, что изоляция снята успешно.*

**2. Проверяем, что интерфейсы вернулись в основную систему**
Теперь смотрим параметры **напрямую**, без приставки `ip netns exec`:

```bash
ip link show enP5p1s0f0
ip link show enP5p1s0f1

```

> **Ожидаемый результат:** В выводе должно быть `mtu 1500` и состояние, отличное от `netns`.

**3. Проверяем физические параметры (Ethtool) в основной системе**
Убеждаемся, что настройки скорости и дуплекса читаются корректно из основной ОС:

```bash
ethtool enP5p1s0f0 | grep -E "Speed|Duplex|Link detected"
ethtool enP5p1s0f1 | grep -E "Speed|Duplex|Link detected"

```

**4. Проверка MTU:**

```bash
ip link show enP5p1s0f0 | grep mtu

```


*Должно быть:* `mtu 1500`.
2. **Проверка видимости:**
Убедитесь, что интерфейсы видны в основной системе (не в `ip netns exec`, а просто `ip link`).
3. **Важное примечание по Sysctl:**
Команда `sysctl --system` вернет значения из конфигурационных файлов. Однако, если какие-то параметры (например, гигантские буферы `rmem_max`) не были явно прописаны в ваших конфигах (`/etc/sysctl.conf`), они могут остаться измененными в оперативной памяти до полной перезагрузки сервера (`reboot`). Для продакшн-систем после таких глубоких тестов **рекомендуется перезагрузка**.

---

## Резюме по диагностике ошибок

Если во время теста вы видите:

1. **rx_missed_errors / rx_fifo_errors:** Карта получила пакет, но не смогла передать его в RAM (PCIe забит или Ring Buffer мал).
* *Лечение:* Увеличить Ring Buffer (`ethtool -G`), проверить PCIe (`lspci`), включить Pause Frames.


2. **rx_no_dma_resources:** Драйверу не хватает памяти.
3. **Symbol errors / CRC errors / FCS errors:** Физическая проблема.
* *Причина:* Плохой кабель, грязная оптика, перегрев SFP, плохой контакт в слоте.


4. **Снижение скорости (retransmits в iperf):** Потеря пакетов где-то в пути. Смотрите счетчики выше.

## Возврат системы в исходное состояние

После тестов важно удалить неймспейсы, чтобы вернуть интерфейсы под управление основной ОС.

```bash
# Удаляем неймспейсы (интерфейсы автоматически вернутся в default netns)
ip netns del ns_sender
ip netns del ns_receiver

# Сброс IP адресов (они могут остаться на интерфейсах)
ip addr flush dev enP5p1s0f0
ip addr flush dev enP5p1s0f1

```
